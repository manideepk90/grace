title: Connector Implementation Patterns
sections:
  - title: Authentication Patterns
    patterns:
      - title: HTTP Basic Auth
        code: |
          let auth_string = format!("{}:{}", username.expose(), password.expose());
          let encoded = base64::engine::general_purpose::STANDARD.encode(auth_string.as_bytes());
          Ok(vec![(headers::AUTHORIZATION.to_string(), format!("Basic {encoded}").into_masked())])
      - title: HMAC Signature (Dlocal Pattern)
        code: |
          // Centralized in ConnectorCommonExt::build_headers
          fn build_headers(&self, req: &RouterData<Flow, Req, Resp>, connectors: &Connectors) -> CustomResult<Vec<(String, Maskable<String>)>, errors::ConnectorError> {
              let request_content = self.get_request_body(req, connectors)?;
              let body_string = match request_content {
                  Some(RequestContent::Json(body)) => body.peek().to_string(),
                  Some(RequestContent::FormUrlEncoded(form)) => form.peek().to_string(),
                  _ => String::new(),
              };
              
              let timestamp = date_time::now();
              let auth = DlocalAuthType::try_from(&req.connector_auth_type)?;
              
              // Signature: X-Login + X-Date + RequestBody
              let to_sign = format!("{}{}{}", auth.x_login, timestamp, body_string);
              let signature = crypto::HmacSha256::sign_message(
                  auth.secret_key.peek().as_bytes(),
                  to_sign.as_bytes(),
              )?;
              
              Ok(vec![
                  ("X-Login".to_string(), auth.x_login.into_masked()),
                  ("X-Trans-Key".to_string(), auth.x_trans_key.into_masked()),
                  ("X-Date".to_string(), timestamp.to_string().into()),
                  ("X-Version".to_string(), "2.1".into()),
                  ("Authorization".to_string(), format!("V2-HMAC-SHA256, Signature: {}", hex::encode(signature)).into()),
              ])
          }
  - title: Data Transformation Patterns
    patterns:
      - title: TryFrom for Auth Response (Avoiding Orphan Rule)
        code: |
          // Use local ResponseRouterData wrapper
          impl TryFrom<ResponseRouterData<AccessTokenAuth, ConnectorAuthResponse, AccessTokenRequestData, AccessToken>>
              for RouterData<AccessTokenAuth, AccessTokenRequestData, AccessToken>
          {
              fn try_from(item: ResponseRouterData<...>) -> Result<Self, Self::Error> {
                  Ok(Self {
                      response: Ok(AccessToken {
                          token: item.response.token_field,
                          expires: item.response.expires_field,
                      }),
                      ..item.data // Spread original RouterData
                  })
              }
          }
      - title: TryFrom for Payment Response
        code: |
          impl TryFrom<ResponseRouterData<Authorize, ConnectorPaymentResponse, PaymentsAuthorizeData, PaymentsResponseData>>
              for RouterData<Authorize, PaymentsAuthorizeData, PaymentsResponseData>
          {
              fn try_from(item: ResponseRouterData<...>) -> Result<Self, Self::Error> {
                  let status = match item.response.status.as_str() {
                      "approved" => AttemptStatus::Charged,
                      "failed" => AttemptStatus::Failure,
                      _ => AttemptStatus::Pending,
                  };
                  
                  Ok(Self {
                      status,
                      response: Ok(PaymentsResponseData::TransactionResponse {
                          resource_id: ResponseId::ConnectorTransactionId(item.response.transaction_id),
                          redirection_data: item.response.redirect_url.map(|url| {
                              Box::new(RedirectForm::Form {
                                  endpoint: url,
                                  method: Method::Get,
                                  form_fields: HashMap::new(),
                              })
                          }),
                          ..Default::default()
                      }),
                      ..item.data
                  })
              }
          }
  - title: Amount Handling
    patterns:
      - title: Minor to Major Unit Conversion
        code: |
          // For connectors expecting f64 major units
          let minor_amount_i64 = item.amount.get_amount_as_i64()?;
          let major_amount_f64 = utils::to_currency_base_unit(minor_amount_i64, currency)?;
      - title: Helper Struct Pattern
        code: |
          pub struct ConnectorRouterData<T> {
              pub amount: MinorUnit, // Or String/f64 based on API
              pub router_data: T,
          }

          impl<T> From<(MinorUnit, T)> for ConnectorRouterData<T> {
              fn from((amount, router_data): (MinorUnit, T)) -> Self {
                  Self { amount, router_data }
              }
          }
  - title: Request Construction
    patterns:
      - title: Signature-Safe Request Body
        code: |
          // 1. Create concrete request
          let connector_req = ConnectorPaymentsRequest::try_from(&connector_router_data)?;

          // 2. Serialize for signature
          let request_str = serde_json::to_string(&connector_req)?;

          // 3. Box for request body
          let request_content = RequestContent::Json(Box::new(connector_req));
      - title: Required ConnectorIntegration Implementations
        description: "Don't forget to implement these connector flows if applicable:"
        flows:
          - PaymentReject
          - PaymentApprove
          - PaymentAuthorizeSessionToken
      - title: Empty Request Bodies
        code: |
          // GET requests: Don't call set_body()

          // POST with empty body
          Ok(RequestContent::Empty)

          // POST with empty JSON
          #[derive(Debug, Serialize)]
          pub struct EmptyRequest {}
          Ok(RequestContent::Json(Box::new(EmptyRequest {})))
  - title: Configuration & Metadata
    patterns:
      - title: Merchant-Specific Config
        code: |
          let gateway_token = req.connector_meta_data
              .as_ref()
              .and_then(|meta| meta.peek().as_object())
              .and_then(|obj| obj.get("gateway_token"))
              .and_then(|token| token.as_str())
              .ok_or(errors::ConnectorError::MissingRequiredField { 
                  field_name: "gateway_token" 
              })?;
      - title: Transaction Token Management
        code: |
          // Store in response
          resource_id: ResponseId::ConnectorTransactionId(response.transaction.token),

          // Retrieve for capture/refund/sync
          let token = req.request.connector_transaction_id.clone();
          // Or for sync
          let token = req.request.get_connector_transaction_id()?;

          // URL pattern
          format!("{}/v1/transactions/{}/capture.json", base_url, token)
  - title: Field Processing
    patterns:
      - title: Name Splitting
        code: |
          let parts: Vec<&str> = name.peek().split_whitespace().collect();
          first_name: parts.first()
              .map(|s| Secret::new(s.to_string()))
              .unwrap_or_else(|| Secret::new("".to_string())),
          last_name: if parts.len() > 1 {
              Some(Secret::new(parts[1..].join(" ")))
          } else {
              None
          }.unwrap_or_else(|| Secret::new("".to_string())),
      - title: Field and Method Names
        points:
          - Use `customer_id` not `connector_customer`
          - Use `get_ip_address_as_optional()` not `get_optional_ip()`
      - title: JSON to HashMap<String, String>
        code: |
          let form_fields = if let Value::Object(map) = json_data {
              map.into_iter()
                  .filter_map(|(k, v)| match v {
                      Value::String(s) => Some((k, s)),
                      Value::Number(n) => Some((k, n.to_string())),
                      Value::Bool(b) => Some((k, b.to_string())),
                      _ => None,
                  })
                  .collect()
          } else {
              HashMap::new()
          };
  - title: Status Mapping
    patterns:
      - title: Multi-Field Status
        code: |
          let status = match (response.transaction_type.as_str(), response.succeeded) {
              ("Authorize", true) => AttemptStatus::Authorized,
              ("Capture", true) => AttemptStatus::Charged,
              ("Void", true) => AttemptStatus::Voided,
              (_, false) => AttemptStatus::Failure,
              _ => AttemptStatus::Pending,
          };
      - title: Enum-Based Status
        code: |
          impl From<ConnectorStatus> for AttemptStatus {
              fn from(status: ConnectorStatus) -> Self {
                  match status {
                      ConnectorStatus::Succeeded => Self::Charged,
                      ConnectorStatus::Authorized => Self::Authorized,
                      ConnectorStatus::Failed => Self::Failure,
                      ConnectorStatus::Pending => Self::Pending,
                  }
              }
          }
  - title: Webhook Patterns
    patterns:
      - title: HMAC-SHA256 Verification
        code: |
          fn verify_webhook_source(&self, request: &IncomingWebhookRequestDetails<'_>, 
              secrets: &ConnectorWebhookSecrets) -> CustomResult<(), ConnectorError> {
              let signature = get_header_key_value("x-signature", request.headers)?;
              let webhook_secret = secrets.secret.as_ref()
                  .ok_or(ConnectorError::WebhookVerificationSecretNotFound)?;
              
              let expected = crypto::HmacSha256::sign_message(
                  webhook_secret.expose().as_bytes(),
                  request.body.as_bytes(),
              )?;
              
              if hex::encode(expected) != signature {
                  return Err(ConnectorError::WebhookSourceVerificationFailed.into());
              }
              Ok(())
          }
      - title: Object Reference ID
        code: |
          fn get_webhook_object_reference_id(&self, request: &IncomingWebhookRequestDetails<'_>) 
              -> CustomResult<ObjectReferenceId, ConnectorError> {
              let webhook: ConnectorWebhook = request.body.parse_struct("ConnectorWebhook")?;
              let payment_id = id_type::PaymentId::try_from(Cow::Owned(webhook.payment_id))?;
              
              Ok(ObjectReferenceId::PaymentId(
                  PaymentIdType::PaymentIntentId(payment_id)
              ))
          }
  - title: Import Patterns
    patterns:
      - title: Request Data Accessor Traits
        code: |
          // In transformers.rs
          use crate::utils::{
              PaymentsAuthorizeRequestData,
              PaymentsPreProcessingRequestData,
              RefundsRequestData,
          };
      - title: Parse Method
        code: |
          // For parse_struct on byte slices
          use common_utils::ext_traits::ByteSliceExt;
  - title: Struct Patterns
    patterns:
      - title: Flat Structures (When API is Simple)
        code: |
          #[derive(Debug, Serialize)]
          pub struct PaymentsRequest {
              transaction: Transaction,
          }

          #[derive(Debug, Serialize)]
          pub struct Transaction {
              amount: StringMinorUnit,
              currency_code: String,
              card_number: cards::CardNumber,
              // Direct fields, not nested
          }
      - title: Derive Requirements
        code: |
          // For event_builder.set_response_body()
          #[derive(Debug, Clone, Deserialize, Serialize)]
          pub struct ConnectorResponse { /* ... */ }

          // For enums in Default structs
          #[derive(Debug, Clone, Default, Deserialize, Serialize)]
          #[serde(rename_all = "SCREAMING_SNAKE_CASE")]
          pub enum Status {
              Succeeded,
              Failed,
              #[default]
              Pending,
          }
  - title: Key Principles
    principles:
      - Use Local Wrappers: Always use `crate::types::ResponseRouterData` for TryFrom to avoid orphan rule
      - Centralize Common Logic: Like HMAC generation in `build_headers`
      - Handle Sensitive Data: Use `peek()` for references, `expose()` only when necessary
      - Simplify When Possible: Match API simplicity with code simplicity
      - Clear Error Messages: Always provide context in errors
      - Type Safety: Use appropriate types (Secret, Email, etc.)
      - Consistent Patterns: Follow established patterns from other connectors
